#!/bin/sh

# Efficiently sync git-controlled source with a remote server.
#
# Uploads both committed and uncommitted data (in files known to git) to the
# remote host.  After running the script, the head of the current branch and
# the state of the working tree on the remote side will match local ones.
#
# The remote host must contain a checkout of the repository in the same
# location under your $HOME.  For example, if you are working from ~/work/repo
# a "work/repo" must exist when you ssh to the server.
#
# Usage from Emacs:
#
# (defun sync-git (hostname)
#   (save-some-buffers)
#   (message "Syncing %s..."
#            (string-trim
#             (shell-command-to-string
#              "git rev-parse --show-toplevel")))
#   (shell-command (format "gitsync %s" hostname)))
#
# (global-set-key "\C-\M-u"
#                 (lambda ()
#                   (interactive)
#                   (sync-git "jump+megalodon-int-dev.node")))

set -e

if [ $# -ne 1 ]; then
   echo "Usage: $0 HOST" >&2
   exit 1
fi

REMOTE=$1

topdir="$(git rev-parse --show-toplevel)"
[ -z "$topdir" ] && exit 1

rel_topdir=${topdir#$HOME/}
local_head=$(git rev-parse HEAD)

loc2rem=/tmp/gitsync$$-loc2rem
rem2loc=/tmp/gitsync$$-rem2loc
bundle=/tmp/gitsync$$-bundle
trap "rm -f $loc2rem $rem2loc $bundle" EXIT

mkfifo $loc2rem $rem2loc

ssh $REMOTE '
set -e
cd '\'"$rel_topdir"\''
git rev-parse HEAD
git rev-list @{u}..HEAD | tr "\n" " "; echo
read b64_bundle
if [ -n "$b64_bundle" ]; then
  echo "$b64_bundle" | base64 -d > /tmp/gitsync$$-fetch
  git fetch -q /tmp/gitsync$$-fetch
  rm /tmp/gitsync$$-fetch
fi
read new_head
echo "resetting '"$REMOTE:$rel_topdir"' to $(git rev-parse --short $new_head)" >&2
git reset --hard $new_head
read b64_diff
if [ -n "$b64_diff" ]; then
  echo "$b64_diff" | base64 -d | git apply -v
fi
' >$rem2loc <$loc2rem &

exec <$rem2loc >$loc2rem

read remote_head
if [ -z "$remote_head" ]; then
    # ssh exited, something went wrong
    exit 1
fi
#echo "got remote_head: $remote_head" >&2
read remote_revs
#echo "got remote_revs: $remote_revs" >&2

if [ "$remote_head" != "$local_head" ]; then
    for rev in $remote_revs; do
        if [ "$(git merge-base HEAD $rev 2>/dev/null)" = $rev ]; then
            remote_base=$rev
            break
        fi
    done
    if [ -z "$remote_base" ]; then
        echo "$0: cannot find familiar commit among $remote_revs; try git pull" >&2
        exit 1
    fi
else
    remote_base=$local_head
fi

# "git bundle" refuses to create an empty bundle, so we must check
if [ "$remote_base" != $local_head ]; then
    echo "sending $(git rev-parse --short $remote_base)..$(git rev-parse --short HEAD)" >&2
    git bundle create $bundle $remote_base..HEAD 2>/dev/null
    cat $bundle | base64 -w0
    echo
else
    # provide newline to the remote, so it can receive the empty line and skip
    # "git fetch"
    echo
fi

git rev-parse HEAD
# use "git diff HEAD" to also catch staged differences
git diff --binary HEAD | base64 -w0
echo

wait
